Fecunditydistribution <- data.frame()
PostFecunditydistribution <- data.frame()
Code.focal = "i"
function.int = 1
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# subset for one Code.focal species
SpDataFocal <- simulated.data[which(simulated.data$focal == Code.focal),]
#SpDataFocal <- simdata
SpDataFocal <- SpDataFocal[which(SpDataFocal$focal == Code.focal),]
SpDataFocal <- SpDataFocal[complete.cases(SpDataFocal$fecundity),]
#SpDataFocal$seeds[is.na(SpDataFocal$seeds)] <- 0
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$fecundity)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("time","focal","seeds.i",
"seeds.j","fecundity","seeds","biomass")]
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(AllSpNames))
SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0
S <- sum(SpToKeep)
SpMatrix <- matrix(NA, nrow = N, ncol = S)
i <- 1
for(s in 1:ncol(AllSpAbunds)){
if(SpToKeep[s] == 1){
SpMatrix[,i] <- AllSpAbunds[,s]
i <- i + 1
}else{next}
}
#SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
#if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}
SpNames <- AllSpNames[SpToKeep]
#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == Code.focal, 1, 0)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 3. BAYES FIT----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##---- 3.1. Set up summary interactions df and parameters ----
run_estimation <- 1
alphaFunct1 <- function.vec[1]
alphaFunct2 <- function.vec[2]
alphaFunct3 <- function.vec[3]
alphaFunct4 <- function.vec[4]
alpha.function <- paste0("function_",which(function.vec==1))
DataVec <- c("N", "S",
"Fecundity", "SpMatrix",
"Intra","run_estimation","alphaFunct1",
"alphaFunct2","alphaFunct3","alphaFunct4")
load(paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"))
FinalPosteriors <- rstan::extract(FinalFit)
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv"))
mu <- FinalPosteriors[["F_hat"]]
disp_dev <- post.draws$disp_dev
phi <- (disp_dev^2)^(-1)
disp_dev <- FinalPosteriors$disp_dev
phi <- (disp_dev^2)^(-1)
# generating posterior predictions
seed_pred <- matrix(nrow = dim(mu)[1], ncol = dim(mu)[2])
for (i in 1:dim(mu)[1]) {     # for each posterior draw
for (j in 1:dim(mu)[2]) {    # for each observation
# draw from the predicted distribution
seed_pred[i, j] <- rnbinom(1, mu = mu[i, j], size = phi[i])
}
}
seed_pred_table <- gather(as_tibble(seed_pred),key = "key",
value = "Fec")
seed_pred_table$obs <- rep(1:dim(mu)[1],each=dim(mu)[2])
seed_pred_table$iterations <- rep(1:dim(mu)[2],times=dim(mu)[1])
# get maximum density for plot limits
max.density <- max(c(apply(seed_pred, 1, function(x) {max(density(x)$y)}),
max(density(stan.data)$y)))
Fecundity
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".RData"))
load("~/Documents/Projects/Density-dependentFunctions/results/PostFec_i_function_1.RData")
# dev.new(noRStudioGD = T)
# start a plot with the first draw
ppc.plot <- plot(density(seed_pred[1, ]), ylim = c(0, max.density), col = 'darkgrey',
ylab = 'Seed density',
main = 'Post. pred. check',
sub = '(grey = predicted, black = observed)')
print(ppc.plot)
ppc.plot <- plot(density(seed_pred[1, ]), ylim = c(0, max.density), col = 'darkgrey',
ylab = 'Seed density',
main = 'Post. pred. check',
sub = '(grey = predicted, black = observed)')
stan.data = Fecundity
# get maximum density for plot limits
max.density <- max(c(apply(seed_pred, 1, function(x) {max(density(x)$y)}),
max(density(stan.data)$y)))
# dev.new(noRStudioGD = T)
# start a plot with the first draw
ppc.plot <- plot(density(seed_pred[1, ]), ylim = c(0, max.density), col = 'darkgrey',
ylab = 'Seed density',
main = 'Post. pred. check',
sub = '(grey = predicted, black = observed)')
for (i in 2:dim(seed_pred)[1]) {
# add a line for each draw
ppc.plot <- lines(density(seed_pred[i, ]), col = 'darkgrey')
}
# add the actual data
ppc.plot <- lines(density(stan.data), col = 'black', lwd = 2)
print(ppc.plot)
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
pdf(paste0("figures/FinalFit_",Code.focal,"_",alpha.function,".pdf"))
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
# plot the corresponding graphs
stan_model_check(FinalFit,
param =c('lambdas','alpha_function_eij','c','alpha_initial','alpha_slope','c'))
# Next check the correlation among key model parameters and identify any
pairs(FinalFit, pars = c("lambdas", 'alpha_function_eij','alpha_initial','alpha_slope','c'))
dev.off()
#---- 3.4. Extraction interactions coefficients---
density.comp <- data.frame(observations= c(1:nrow(SpDataFocal)),
species.i = SpDataFocal$i,
species.j = SpDataFocal$j)
density.comp <- data.frame(observations= c(1:nrow(SpDataFocal)),
species.i = SpDataFocal$i,
species.j = SpDataFocal$j)
nrow(SpDataFocal)
density.comp <- data.frame(observations= c(1:nrow(SpDataFocal)),
species.i = SpDataFocal$plants.i,
species.j = SpDataFocal$plants.j)
Alphadistribution.i <- tibble()
Alphadistribution.j <- tibble()
Alphadistribution.i <- data.frame(FinalPosteriors$alpha_function_eij[,,1])
names(Alphadistribution.i) <- c(1:nrow(SpDataFocal))
Alphadistribution.i <- gather(Alphadistribution.i, key="observations",value="alpha.i")
Alphadistribution.i$observations <- as.numeric(Alphadistribution.i$observations)
Alphadistribution.i <- full_join(Alphadistribution.i,density.comp,
by=c("observations"))
Alphadistribution.j <- as.data.frame(FinalPosteriors$alpha_function_eij[,,2])
names(Alphadistribution.j) <- c(1:nrow(SpDataFocal))
Alphadistribution.j <- gather(Alphadistribution.j, key="observations",value="alpha.j")
Alphadistribution.j$observations <- as.numeric(Alphadistribution.j$observations)
Alphadistribution.j <- full_join(Alphadistribution.j,density.comp, by=c("observations"))
Alphadistribution.i <- Alphadistribution.i %>%
group_by(species.i) %>% summarise_at("alpha.i",  list(mean = mean, sd = sd))
Alphadistribution.i <- data.frame(abundance.neighbours = Alphadistribution.i$species.i,
alpha_mean = Alphadistribution.i$mean,
alpha_sd= Alphadistribution.i$sd,
neighbours= "species i",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.j <- Alphadistribution.j %>%
group_by(species.j) %>% summarise_at("alpha.j",  list(mean = mean, sd = sd))
Alphadistribution.j <- data.frame(abundance.neighbours = Alphadistribution.j$species.j,
alpha_mean = Alphadistribution.j$mean,
alpha_sd= Alphadistribution.j$sd,
neighbours= "species j",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.neighbours <- bind_rows(Alphadistribution.neighbours,Alphadistribution.i,Alphadistribution.j)
Fecunditydistribution.n <- FinalPosteriors %>%
as.data.frame() %>%
dplyr::select(contains("F_sim")) %>%
gather( key="obervation",value="seed")
Fecunditydistribution.n$focal = paste("species",Code.focal)
Fecunditydistribution.n$density.function = alpha.function
Fecunditydistribution <- bind_rows(Fecunditydistribution,Fecunditydistribution.n)
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv"))
PostFecunditydistribution.n$focal <- Code.focal
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
PostFecunditydistribution.n$focal <- Code.focal
PostFecunditydistribution.n$alpha.function <- alpha.function
PostFecunditydistribution <- bind_rows(PostFecunditydistribution,PostFecunditydisribution.n)
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
pdf(paste0("figures/FinalFit_",Code.focal,"_",alpha.function,".pdf"))
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
# plot the corresponding graphs
stan_model_check(FinalFit,
param =c('lambdas','c','alpha_initial','alpha_slope','c'))
# Next check the correlation among key model parameters and identify any
pairs(FinalFit, pars = c("lambdas",'alpha_initial','alpha_slope','c'))
dev.off()
Fecunditydistribution.n <- FinalPosteriors %>%
as.data.frame() %>%
dplyr::select(contains("F_sim")) %>%
gather( key="obervation",value="seed")
Fecunditydistribution.n$focal = paste("species",Code.focal)
Fecunditydistribution.n$density.function = alpha.function
Fecunditydistribution <- bind_rows(Fecunditydistribution,Fecunditydistribution.n)
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
PostFecunditydistribution.n$focal <- Code.focal
PostFecunditydistribution.n$alpha.function <- alpha.function
PostFecunditydistribution <- bind_rows(PostFecunditydistribution,PostFecunditydisribution.n)
PostFecunditydistribution <- bind_rows(PostFecunditydistribution,PostFecunditydistribution.n)
for(Code.focal in c("i","j")){
for (function.int in c(2:4)){
print(paste(Code.focal,", function",function.int))
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# subset for one Code.focal species
SpDataFocal <- simulated.data[which(simulated.data$focal == Code.focal),]
#SpDataFocal <- simdata
SpDataFocal <- SpDataFocal[which(SpDataFocal$focal == Code.focal),]
SpDataFocal <- SpDataFocal[complete.cases(SpDataFocal$fecundity),]
#SpDataFocal$seeds[is.na(SpDataFocal$seeds)] <- 0
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$fecundity)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("time","focal","seeds.i",
"seeds.j","fecundity","seeds","biomass")]
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(AllSpNames))
SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0
S <- sum(SpToKeep)
SpMatrix <- matrix(NA, nrow = N, ncol = S)
i <- 1
for(s in 1:ncol(AllSpAbunds)){
if(SpToKeep[s] == 1){
SpMatrix[,i] <- AllSpAbunds[,s]
i <- i + 1
}else{next}
}
#SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
#if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}
SpNames <- AllSpNames[SpToKeep]
#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == Code.focal, 1, 0)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 3. BAYES FIT----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##---- 3.1. Set up summary interactions df and parameters ----
run_estimation <- 1
alphaFunct1 <- function.vec[1]
alphaFunct2 <- function.vec[2]
alphaFunct3 <- function.vec[3]
alphaFunct4 <- function.vec[4]
alpha.function <- paste0("function_",which(function.vec==1))
DataVec <- c("N", "S",
"Fecundity", "SpMatrix",
"Intra","run_estimation","alphaFunct1",
"alphaFunct2","alphaFunct3","alphaFunct4")
##---- 3.2. Run  final fit ----
# Now run a fianl fit of the model to assess parameter
print("Final Fit beginning")
#install.packages("codetools")
library("codetools")
options(mc.cores = parallel::detectCores())
FinalFit <- stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
save(file= paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"),
FinalFit)
load(paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"))
FinalPosteriors <- rstan::extract(FinalFit)
print("Final Fit done")
#---- 3.3. Final fit posterior check and behavior checks----
##### Diagnostic plots and post prediction
pdf(paste0("figures/FinalFit_",Code.focal,"_",alpha.function,".pdf"))
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
# plot the corresponding graphs
stan_model_check(FinalFit,
param =c('lambdas','c','alpha_initial','alpha_slope','c'))
# Next check the correlation among key model parameters and identify any
pairs(FinalFit, pars = c("lambdas",'alpha_initial','alpha_slope','c'))
dev.off()
#---- 3.4. Extraction interactions coefficients---
density.comp <- data.frame(observations= c(1:nrow(SpDataFocal)),
species.i = SpDataFocal$plants.i,
species.j = SpDataFocal$plants.j)
Alphadistribution.i <- tibble()
Alphadistribution.j <- tibble()
Alphadistribution.i <- data.frame(FinalPosteriors$alpha_function_eij[,,1])
names(Alphadistribution.i) <- c(1:nrow(SpDataFocal))
Alphadistribution.i <- gather(Alphadistribution.i, key="observations",value="alpha.i")
Alphadistribution.i$observations <- as.numeric(Alphadistribution.i$observations)
Alphadistribution.i <- full_join(Alphadistribution.i,density.comp,
by=c("observations"))
Alphadistribution.j <- as.data.frame(FinalPosteriors$alpha_function_eij[,,2])
names(Alphadistribution.j) <- c(1:nrow(SpDataFocal))
Alphadistribution.j <- gather(Alphadistribution.j, key="observations",value="alpha.j")
Alphadistribution.j$observations <- as.numeric(Alphadistribution.j$observations)
Alphadistribution.j <- full_join(Alphadistribution.j,density.comp, by=c("observations"))
Alphadistribution.i <- Alphadistribution.i %>%
group_by(species.i) %>% summarise_at("alpha.i",  list(mean = mean, sd = sd))
Alphadistribution.i <- data.frame(abundance.neighbours = Alphadistribution.i$species.i,
alpha_mean = Alphadistribution.i$mean,
alpha_sd= Alphadistribution.i$sd,
neighbours= "species i",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.j <- Alphadistribution.j %>%
group_by(species.j) %>% summarise_at("alpha.j",  list(mean = mean, sd = sd))
Alphadistribution.j <- data.frame(abundance.neighbours = Alphadistribution.j$species.j,
alpha_mean = Alphadistribution.j$mean,
alpha_sd= Alphadistribution.j$sd,
neighbours= "species j",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.neighbours <- bind_rows(Alphadistribution.neighbours,Alphadistribution.i,Alphadistribution.j)
#---- 3.4. Extraction fecundity---
Fecunditydistribution.n <- FinalPosteriors %>%
as.data.frame() %>%
dplyr::select(contains("F_sim")) %>%
gather( key="obervation",value="seed")
Fecunditydistribution.n$focal = paste("species",Code.focal)
Fecunditydistribution.n$density.function = alpha.function
Fecunditydistribution <- bind_rows(Fecunditydistribution,Fecunditydistribution.n)
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
PostFecunditydistribution.n$focal <- Code.focal
PostFecunditydistribution.n$alpha.function <- alpha.function
PostFecunditydistribution <- bind_rows(PostFecunditydistribution,PostFecunditydistribution.n)
}
}
Code.focal
for (function.int in c(1)){
print(paste(Code.focal,", function",function.int))
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# subset for one Code.focal species
SpDataFocal <- simulated.data[which(simulated.data$focal == Code.focal),]
#SpDataFocal <- simdata
SpDataFocal <- SpDataFocal[which(SpDataFocal$focal == Code.focal),]
SpDataFocal <- SpDataFocal[complete.cases(SpDataFocal$fecundity),]
#SpDataFocal$seeds[is.na(SpDataFocal$seeds)] <- 0
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$fecundity)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("time","focal","seeds.i",
"seeds.j","fecundity","seeds","biomass")]
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(AllSpNames))
SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0
S <- sum(SpToKeep)
SpMatrix <- matrix(NA, nrow = N, ncol = S)
i <- 1
for(s in 1:ncol(AllSpAbunds)){
if(SpToKeep[s] == 1){
SpMatrix[,i] <- AllSpAbunds[,s]
i <- i + 1
}else{next}
}
#SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
#if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}
SpNames <- AllSpNames[SpToKeep]
#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == Code.focal, 1, 0)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 3. BAYES FIT----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##---- 3.1. Set up summary interactions df and parameters ----
run_estimation <- 1
alphaFunct1 <- function.vec[1]
alphaFunct2 <- function.vec[2]
alphaFunct3 <- function.vec[3]
alphaFunct4 <- function.vec[4]
alpha.function <- paste0("function_",which(function.vec==1))
DataVec <- c("N", "S",
"Fecundity", "SpMatrix",
"Intra","run_estimation","alphaFunct1",
"alphaFunct2","alphaFunct3","alphaFunct4")
##---- 3.2. Run  final fit ----
# Now run a fianl fit of the model to assess parameter
print("Final Fit beginning")
#install.packages("codetools")
library("codetools")
options(mc.cores = parallel::detectCores())
FinalFit <- stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
save(file= paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"),
FinalFit)
load(paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"))
FinalPosteriors <- rstan::extract(FinalFit)
print("Final Fit done")
#---- 3.3. Final fit posterior check and behavior checks----
##### Diagnostic plots and post prediction
pdf(paste0("figures/FinalFit_",Code.focal,"_",alpha.function,".pdf"))
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
# plot the corresponding graphs
stan_model_check(FinalFit,
param =c('lambdas','c','alpha_initial','alpha_slope','c'))
# Next check the correlation among key model parameters and identify any
pairs(FinalFit, pars = c("lambdas",'alpha_initial','alpha_slope','c'))
dev.off()
#---- 3.4. Extraction interactions coefficients---
density.comp <- data.frame(observations= c(1:nrow(SpDataFocal)),
species.i = SpDataFocal$plants.i,
species.j = SpDataFocal$plants.j)
Alphadistribution.i <- tibble()
Alphadistribution.j <- tibble()
Alphadistribution.i <- data.frame(FinalPosteriors$alpha_function_eij[,,1])
names(Alphadistribution.i) <- c(1:nrow(SpDataFocal))
Alphadistribution.i <- gather(Alphadistribution.i, key="observations",value="alpha.i")
Alphadistribution.i$observations <- as.numeric(Alphadistribution.i$observations)
Alphadistribution.i <- full_join(Alphadistribution.i,density.comp,
by=c("observations"))
Alphadistribution.j <- as.data.frame(FinalPosteriors$alpha_function_eij[,,2])
names(Alphadistribution.j) <- c(1:nrow(SpDataFocal))
Alphadistribution.j <- gather(Alphadistribution.j, key="observations",value="alpha.j")
Alphadistribution.j$observations <- as.numeric(Alphadistribution.j$observations)
Alphadistribution.j <- full_join(Alphadistribution.j,density.comp, by=c("observations"))
Alphadistribution.i <- Alphadistribution.i %>%
group_by(species.i) %>% summarise_at("alpha.i",  list(mean = mean, sd = sd))
Alphadistribution.i <- data.frame(abundance.neighbours = Alphadistribution.i$species.i,
alpha_mean = Alphadistribution.i$mean,
alpha_sd= Alphadistribution.i$sd,
neighbours= "species i",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.j <- Alphadistribution.j %>%
group_by(species.j) %>% summarise_at("alpha.j",  list(mean = mean, sd = sd))
Alphadistribution.j <- data.frame(abundance.neighbours = Alphadistribution.j$species.j,
alpha_mean = Alphadistribution.j$mean,
alpha_sd= Alphadistribution.j$sd,
neighbours= "species j",focal = paste("species",Code.focal),
density.function = alpha.function)
Alphadistribution.neighbours <- bind_rows(Alphadistribution.neighbours,Alphadistribution.i,Alphadistribution.j)
#---- 3.4. Extraction fecundity---
Fecunditydistribution.n <- FinalPosteriors %>%
as.data.frame() %>%
dplyr::select(contains("F_sim")) %>%
gather( key="obervation",value="seed")
Fecunditydistribution.n$focal = paste("species",Code.focal)
Fecunditydistribution.n$density.function = alpha.function
Fecunditydistribution <- bind_rows(Fecunditydistribution,Fecunditydistribution.n)
PostFecunditydistribution.n  <- read.csv(paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
PostFecunditydistribution.n$focal <- Code.focal
PostFecunditydistribution.n$alpha.function <- alpha.function
PostFecunditydistribution <- bind_rows(PostFecunditydistribution,PostFecunditydistribution.n)
}
save(Alphadistribution.neighbours, file = "results/Alphadistribution.neighbours.csv.gz")
save(Fecunditydistribution, file = "results/Fecunditydistribution.csv.gz")
save(PostFecunditydistribution , file = "results/PostFecunditydistribution.csv.gz")
library(ggplot2)
library(ggridges)
library(tidyverse)
