for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik <- loo::extract_log_lik(FinalFit,
parameter_name = "F_sim",
merge_chains = F)
#as of loo v2.0.0 we can optionally provide relative effective sample sizes
# when calling loo, which allows for better estimates of the PSIS effective
# sample sizes and Monte Carlo error
r_eff <- loo::relative_eff(exp(log_lik), cores = 2)
# preferably use more than 2 cores (as many cores as possible)
# will use value of 'mc.cores' option if cores is not specified
model.loo[[paste0(scenario,"_",Code.focal,"_function_",function.int)]] <- loo::loo(log_lik,
r_eff = r_eff, cores = 2)
remove(FinalFit)
}
}
}
Se_loo_model <- NULL
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
comp <- loo_compare(model.loo[[paste0(scenario,"_",Code.focal,"_","function_1")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_2")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_3")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_4")]])
model.loo[[Code.focal]] <- comp # The first column shows the difference in ELPD relative to the model with the largest ELPD.
df_loo <- data.frame(se_diff = model.loo[[Code.focal]][,"se_diff"]) %>%
rownames_to_column(var = "model") %>%
mutate(model = stringi::stri_sub(model,from =6,to=6),
scenario = scenario,
focal = Code.focal)
Se_loo_model <- bind_rows(Se_loo_model, df_loo)
}
assign(paste0("model.loo.",scenario),
model.loo)
}
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/stan_modelcheck_rem.R", local = knitr::knit_global()) #
for( scenario in c("low","medium","high")){
dev.new(width=16,height=7)
par(oma=c(0,0,0,0), mar=c(2.25,2.5,2,1))
layout(mat = matrix(
1:8,
byrow=TRUE,
nrow = 2,
ncol = 4
),
heights = rep(2,6),
widths = rep(3,8)
)
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
simdata <- read.csv(paste0("results/Generate.simulated.data.",scenario,".csv"))
simdata <- simdata[which(simdata$time >= time.exp.min &
simdata$time < time.exp.max &
simdata$focal == Code.focal),]
col2 <- c("black","#CC79A7","#E69F00","#009E73")
col1 <- c("blue","red")
if(Code.focal=="i"){int.focal <- 1}else{int.focal <- 2}
value.se <- round(Se_loo_model$se_diff[which(Se_loo_model$model == function.int &
Se_loo_model$scenario == scenario &
Se_loo_model$focal == Code.focal)],digits=2)
FinalPosteriors <- rstan::extract(FinalFit)
stan_post_pred_check_all(FinalPosteriors,"F_hat",
simdata$fecundity[!is.na(simdata$fecundity)],
paste0(scenario," for species ",Code.focal,",function ",function.int),
col1[int.focal],
col2[function.int ],
value.se)
}
}
}
for( scenario in c("low","medium","high")){
load(paste0("results/Alphadistribution.",scenario,".neighbours.csv.gz"))
Alphadistribution.neighbours$interaction <- paste0("alpha_",
substr(Alphadistribution.neighbours$focal,9,9),
substr(Alphadistribution.neighbours$neighbours,9,9))
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= c(abundance.neighbours - Nmax),
y=alpha_mean)) +
geom_hline(yintercept=0,color="dark grey") +
stat_smooth(geom='line',
aes(
color=density.function),
alpha=0.7,se=F,size=2)+
geom_point(aes(
color=density.function,
fill=density.function),alpha=0.8,size=2) +
#ylim(-0.1,0.1)+
#xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.5) +
guides(fill="none") +
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ") +
geom_text(mapping = aes(x = max(abundance.neighbours - Nmax),
y = max(alpha_mean)-0.1, label = interaction),
hjust   = 1) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw()
AlphadistributionGraph
}
for( scenario in c("low","medium","high")){
load(paste0("results/Alphadistribution.",scenario,".neighbours.csv.gz"))
Alphadistribution.neighbours$interaction <- paste0("alpha_",
substr(Alphadistribution.neighbours$focal,9,9),
substr(Alphadistribution.neighbours$neighbours,9,9))
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= c(abundance.neighbours - Nmax),
y=alpha_mean)) +
geom_hline(yintercept=0,color="dark grey") +
stat_smooth(geom='line',
aes(
color=density.function),
alpha=0.7,se=F,linewidth=2)+
geom_point(aes(
color=density.function,
fill=density.function),alpha=0.8,size=2) +
#ylim(-0.1,0.1)+
#xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.5) +
guides(fill="none") +
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ") +
geom_text(mapping = aes(x = max(abundance.neighbours - Nmax),
y = max(alpha_mean)-0.1, label = interaction),
hjust   = 1) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw()
AlphadistributionGraph
}
for( scenario in c("low","medium","high")){
load(paste0("results/Alphadistribution.",scenario,".neighbours.csv.gz"))
Alphadistribution.neighbours$interaction <- paste0("alpha_",                      substr(Alphadistribution.neighbours$focal,9,9),                                                   substr(Alphadistribution.neighbours$neighbours,9,9))
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= c(abundance.neighbours - Nmax),
y=alpha_mean)) +
geom_hline(yintercept=0,color="dark grey") +
stat_smooth(geom='line',
aes(
color=density.function),
alpha=0.7,se=F,linewidth=2)+
geom_point(aes(
color=density.function,
fill=density.function),alpha=0.8,size=2) +
#ylim(-0.1,0.1)+
#xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.5) +
guides(fill="none") +
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ") +
geom_text(mapping = aes(x = max(abundance.neighbours - Nmax),
y = max(alpha_mean)-0.1, label = interaction),
hjust   = 1) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw()
AlphadistributionGraph
}
model.loo <- list()
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik <- loo::extract_log_lik(FinalFit,
parameter_name = "F_sim",
merge_chains = F)
#as of loo v2.0.0 we can optionally provide relative effective sample sizes
# when calling loo, which allows for better estimates of the PSIS effective
# sample sizes and Monte Carlo error
r_eff <- loo::relative_eff(exp(log_lik), cores = 2)
# preferably use more than 2 cores (as many cores as possible)
# will use value of 'mc.cores' option if cores is not specified
model.loo[[paste0(scenario,"_",Code.focal,"_function_",function.int)]] <- loo::loo(log_lik,
r_eff = r_eff, cores = 2)
remove(FinalFit)
}
}
}
Se_loo_model <- NULL
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
comp <- loo_compare(model.loo[[paste0(scenario,"_",Code.focal,"_","function_1")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_2")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_3")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_4")]])
model.loo[[Code.focal]] <- comp # The first column shows the difference in ELPD relative to the model with the largest ELPD.
df_loo <- data.frame(se_diff = model.loo[[Code.focal]][,"se_diff"]) %>%
rownames_to_column(var = "model") %>%
mutate(model = stringi::stri_sub(model,from =6,to=6),
scenario = scenario,
focal = Code.focal)
Se_loo_model <- bind_rows(Se_loo_model, df_loo)
}
assign(paste0("model.loo.",scenario),
model.loo)
}
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/stan_modelcheck_rem.R", local = knitr::knit_global()) #
for( scenario in c("low","medium","high")){
dev.new(width=16,height=7)
par(oma=c(0,0,0,0), mar=c(2.25,2.5,2,1))
layout(mat = matrix(
1:24,
byrow=TRUE,
nrow = 6,
ncol = 4
),
heights = rep(6,6),
widths = rep(4,8)
)
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
simdata <- read.csv(paste0("results/Generate.simulated.data.",scenario,".csv"))
simdata <- simdata[which(simdata$time >= time.exp.min &
simdata$time < time.exp.max &
simdata$focal == Code.focal),]
col2 <- c("black","#CC79A7","#E69F00","#009E73")
col1 <- c("blue","red")
if(Code.focal=="i"){int.focal <- 1}else{int.focal <- 2}
value.se <- round(Se_loo_model$se_diff[which(Se_loo_model$model == function.int &
Se_loo_model$scenario == scenario &
Se_loo_model$focal == Code.focal)],digits=2)
FinalPosteriors <- rstan::extract(FinalFit)
stan_post_pred_check_all(FinalPosteriors,"F_hat",
simdata$fecundity[!is.na(simdata$fecundity)],
paste0(scenario," for species ",Code.focal,",function",function.int),
col1[int.focal],
col2[function.int ],
value.se)
}
}
}
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(loo) # Efficient approximate leave-one-out cross-validation
library("HDInterval")
library("tidyverse")
library(dplyr)
library(ggpubr)
library(ggplot2)
library(odeintr)
library(brms)
library(bbmle)
ModelCheck <- NULL
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
print(paste(scenario, Code.focal,", function",function.int))
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
mc <- data.frame( scenario = scenario, focal =Code.focal,
function.int = function.int,
Rhat = max(summary(FinalFit)$summary[,"Rhat"],na.rm =T),
Neff = min(summary(FinalFit)$summary[,"n_eff"],na.rm = T))
ModelCheck <- bind_rows(ModelCheck,mc)
#remove(FinalFit)
}
}
}
ModelCheck
model.loo <- list()
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik <- loo::extract_log_lik(FinalFit,
parameter_name = "F_sim",
merge_chains = F)
#as of loo v2.0.0 we can optionally provide relative effective sample sizes
# when calling loo, which allows for better estimates of the PSIS effective
# sample sizes and Monte Carlo error
r_eff <- loo::relative_eff(exp(log_lik), cores = 2)
# preferably use more than 2 cores (as many cores as possible)
# will use value of 'mc.cores' option if cores is not specified
model.loo[[paste0(scenario,"_",Code.focal,"_function_",function.int)]] <- loo::loo(log_lik,
r_eff = r_eff, cores = 2)
remove(FinalFit)
}
}
}
Se_loo_model <- NULL
for( scenario in c("low","medium","high")){
for(Code.focal in c("i","j")){ #,"j"
comp <- loo_compare(model.loo[[paste0(scenario,"_",Code.focal,"_","function_1")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_2")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_3")]],
model.loo[[paste0(scenario,"_",Code.focal,"_","function_4")]])
model.loo[[Code.focal]] <- comp # The first column shows the difference in ELPD relative to the model with the largest ELPD.
df_loo <- data.frame(se_diff = model.loo[[Code.focal]][,"se_diff"]) %>%
rownames_to_column(var = "model") %>%
mutate(model = stringi::stri_sub(model,from =6,to=6),
scenario = scenario,
focal = Code.focal)
Se_loo_model <- bind_rows(Se_loo_model, df_loo)
}
assign(paste0("model.loo.",scenario),
model.loo)
}
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/stan_modelcheck_rem.R", local = knitr::knit_global()) #
for( scenario in c("low","medium","high")){
dev.new(width=16,height=7)
par(oma=c(0,0,0,0), mar=c(2.25,2.5,2,1))
layout(mat = matrix(
1:24,
byrow=TRUE,
nrow = 6,
ncol = 4
),
heights = rep(6,6),
widths = rep(4,8)
)
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
simdata <- read.csv(paste0("results/Generate.simulated.data.",scenario,".csv"))
simdata <- simdata[which(simdata$time >= time.exp.min &
simdata$time < time.exp.max &
simdata$focal == Code.focal),]
col2 <- c("black","#CC79A7","#E69F00","#009E73")
col1 <- c("blue","red")
if(Code.focal=="i"){int.focal <- 1}else{int.focal <- 2}
value.se <- round(Se_loo_model$se_diff[which(Se_loo_model$model == function.int &
Se_loo_model$scenario == scenario &
Se_loo_model$focal == Code.focal)],digits=2)
FinalPosteriors <- rstan::extract(FinalFit)
stan_post_pred_check_all(FinalPosteriors,"F_hat",
simdata$fecundity[!is.na(simdata$fecundity)],
paste0(scenario," for species ",Code.focal,",function",function.int),
col1[int.focal],
col2[function.int ],
value.se)
}
}
}
for( scenario in c("low","medium","high")){
#dev.new(width=16,height=7)
par(oma=c(0,0,0,0), mar=c(2.25,2.5,2,1))
layout(mat = matrix(
1:24,
byrow=TRUE,
nrow = 6,
ncol = 4
),
heights = rep(6,6),
widths = rep(4,8)
)
for(Code.focal in c("i","j")){ #,"j"
for (function.int in c(1:4)){ # c(1:4)
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
simdata <- read.csv(paste0("results/Generate.simulated.data.",scenario,".csv"))
simdata <- simdata[which(simdata$time >= time.exp.min &
simdata$time < time.exp.max &
simdata$focal == Code.focal),]
col2 <- c("black","#CC79A7","#E69F00","#009E73")
col1 <- c("blue","red")
if(Code.focal=="i"){int.focal <- 1}else{int.focal <- 2}
value.se <- round(Se_loo_model$se_diff[which(Se_loo_model$model == function.int &
Se_loo_model$scenario == scenario &
Se_loo_model$focal == Code.focal)],digits=2)
FinalPosteriors <- rstan::extract(FinalFit)
stan_post_pred_check_all(FinalPosteriors,"F_hat",
simdata$fecundity[!is.na(simdata$fecundity)],
paste0(scenario," for species ",Code.focal,",function",function.int),
col1[int.focal],
col2[function.int ],
value.se)
}
}
}
knitr::include_graphics("figures/PostFecundity_distribution_low.pdf")
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(loo) # Efficient approximate leave-one-out cross-validation
library("HDInterval")
library("tidyverse")
library(dplyr)
library(ggpubr)
library(ggplot2)
library(odeintr)
library(brms)
library(bbmle)
knitr::include_graphics("/figures/PostFecundity_distribution_low.pdf")
knitr::include_graphics("~/figures/PostFecundity_distribution_low.pdf")
knitr::include_graphics("./figures/PostFecundity_distribution_low.pdf")
knitr::include_graphics("./figures/PostFecundity_distribution_low.pdf")
knitr::include_graphics("./figures/AlphadistributionGraphlow.pdf")
knitr::include_graphics("./figures/PostFecundity_distribution_low.pdf")
knitr::include_graphics("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/figures/AlphadistributionGraphlow.pdf")
knitr::include_graphics("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/figures/AlphadistributionGraphlow.pdf")
tinytex::install_tinytex()
#| echo: true
#| eval: false # skip evaluation
#| file: C:/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/GenerateSimData_Ricker.R
#source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/GenerateSimData_Ricker.R",local = knitr::knit_global())
set.seed(16)
simul_data_ricker <- simul_data(S = 2,   # number of focal groups/species
K = 2,   # number of neighbour focals
pI = 0.1) # Generate Simulated data in "simulated.data" df and
simdata <- simul_data_ricker$simdata
cols.num <- c("seeds","i","j")
simdata[cols.num] <- sapply(simdata[cols.num],as.numeric)
ggplot(simdata, aes(x=seeds, color=as.factor(focal))) +
geom_density(alpha=0.5) +
scale_x_continuous(name = "Viable seed, fecundity per individuals (log transformed)", limits=c(0,200)) +
theme_bw()
library(here)
Alphadistribution.neighbours.Ricker <- read_csv2("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal") %>%
gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
mutate(focal = case_when(focal == "focali" ~ "species i",
focal == "focalj" ~ "species j"),
neighbours = case_when(neighbours == "alphai" ~ "species i",
neighbours == "alphaj" ~ "species j"))
ggplot() +
geom_smooth(data=Alphadistribution.neighbours.Ricker, aes(x= abundance.neighbours,
y=alpha_mean,
color=density.function,
fill=density.function),
alpha=0.5,se=F) +
geom_point(data=Alphadistribution.neighbours.Ricker,aes(
x= abundance.neighbours,
y=alpha_mean,
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
geom_hline( data=sim_alpha_specific ,aes(yintercept=alpha_sim),color="blue") +
geom_errorbar(data=Alphadistribution.neighbours.Ricker,
aes(x= abundance.neighbours,
y=alpha_mean,
ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none") +
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions from RICKER simulation data",
y="Resulting effect", x=" Neighbour density ")
simul_data_ricker <- read_csv2("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal") %>%
gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
mutate(focal = case_when(focal == "focali" ~ "species i",
focal == "focalj" ~ "species j"),
neighbours = case_when(neighbours == "alphai" ~ "species i",
neighbours == "alphaj" ~ "species j"))
library(data.table)
library(rstan)
library(loo) # Efficient approximate leave-one-out cross-validation
library("HDInterval")
library("tidyverse")
library(dplyr)
library(ggpubr)
library(ggplot2)
library(odeintr)
library(brms)
library(bbmle)
library(data.table)
simul_data_ricker <- fread("results/Alphadistribution.neighbours.Ricker.csv.gz")
install.packages('R.utils')
simul_data_ricker <- fread("results/Alphadistribution.neighbours.Ricker.csv.gz")
simul_data_ricker =fread("results/Alphadistribution.neighbours.Ricker.csv.gz")
library(tidyverse)
simul_data_ricker <- read_csv("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal") %>%
gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
mutate(focal = case_when(focal == "focali" ~ "species i",
focal == "focalj" ~ "species j"),
neighbours = case_when(neighbours == "alphai" ~ "species i",
neighbours == "alphaj" ~ "species j"))
str(simul_data_ricker)
library(readr)
simul_data_ricker <- read_csv("results/Alphadistribution.neighbours.Ricker.csv.gz")
str(simul_data_ricker)
head(simul_data_ricker)
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal") %>%
gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
mutate(focal = case_when(focal == "focali" ~ "species i",
focal == "focalj" ~ "species j"),
neighbours = case_when(neighbours == "alphai" ~ "species i",
neighbours == "alphaj" ~ "species j"))
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
str(simul_data_ricker)
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific)
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal")
str(sim_alpha_specific)
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
rownames_to_column(var = "focal") %>%
gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
mutate(focal = case_when(focal == "focali" ~ "species i",
focal == "focalj" ~ "species j"),
neighbours = case_when(neighbours == "alphai" ~ "species i",
neighbours == "alphaj" ~ "species j"))
sim_alpha_specific <- as.data.frame(simul_data_ricker)
load("results/Alphadistribution.neighbours.Ricker.csv.gz")
sim_alpha_specific <- as.data.frame(simul_data_ricker)
str(sim_alpha_specific)
