dev.off()
}
#---- 3.3. Extract coefficients ----
assign(paste0("Parameters_",Code.focal,"_",alpha.function),
list(DataVec = DataVec,
alpha_value= FinalPosteriors$alpha_value,
lambda =  FinalPosteriors$lambda_ei,
alpha_slope= FinalPosteriors$alpha_slope,
alpha_init =FinalPosteriors$alpha_init,
alpha_c = FinalPosteriors$c
))
save(list =paste0("Parameters_",Code.focal,"_",alpha.function),
file = paste0("results/stan/Parameters_",Code.focal,"_",alpha.function,".RData"))
#---- 3.3. Extraction fecundity---
assign(paste0("Fsim_",Code.focal,"_",alpha.function),
list(DataVec = DataVec,
F_sim=FinalPosteriors$F_sim
))
save(list =paste0("Fsim_",Code.focal,"_",alpha.function),
file = paste0("results/stan/Fsim_",Code.focal,"_",alpha.function,".RData"))
}
}
for(Code.focal in focal.levels){
for (function.int in c(1:4)){
print(paste(Code.focal,", function",function.int))
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# data for the focal
SpDataFocal <- Spcompetition[[Code.focal]]
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$seeds)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("focal","year","day","month",
"block","unique.plot",
"flower","seeds","individual")]
if( function.grouping ==1){
AllSpNames <- c("forb","grass",focal.levels)
}
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(c(AllSpNames)))%>%
mutate_at( AllSpNames, as.numeric)
SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0
NamesSpToKeep <-names(SpToKeep)
Stotal <- sum(SpToKeep)
#SpMatrix <- matrix(NA, nrow = N, ncol = S)
#i <- 1
#for(s in 1:ncol(AllSpAbunds)){
#if(SpToKeep[s] == 1){
# SpMatrix[,i] <- AllSpAbunds[,s]
#  i <- i + 1
# }else{next}
#}
S <- 1 + length(focal.levels)
if( function.grouping ==1){
S <-  sum(SpToKeep)
}
SpMatrix <- as.data.frame(matrix(NA, nrow = N, ncol = S ))
#i <- 1
for(i in 1:N){
if( function.grouping ==1){
SpMatrix <- AllSpAbunds
}else{
SpMatrix[i,1] <- sum(AllSpAbunds[i,NamesSpToKeep[!NamesSpToKeep %in% focal.levels]])
SpMatrix[i,c(2:S)] <- AllSpAbunds[i,focal.levels]
names(SpMatrix) <-c("Neighbours",focal.levels)
}
}
SpMatrix <- as.matrix(SpMatrix)
#SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
#if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}
SpNames <- AllSpNames[SpToKeep]
#SpNames <-c("Neighbours",focal.levels)
#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == Code.focal, 1, 0)
# max fecundity
Nmax <- c(SpMatrix[which.max(Fecundity),])
# Upper bound intrinsic fecundity
U <- ceiling(log(fecundity.summary$mean.seed[which(fecundity.summary$focal==Code.focal)]))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 3. BAYES FIT----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##---- 3.1. Set up summary interactions df and parameters ----
run_estimation <- 1
alphaFunct1 <- function.vec[1]
alphaFunct2 <- function.vec[2]
alphaFunct3 <- function.vec[3]
alphaFunct4 <- function.vec[4]
alpha.function <- paste0("function_",which(function.vec==1))
DataVec <- list(N=N,
S=S,
U= U,
Nmax=Nmax,
Fecundity=Fecundity,
SpMatrix =SpMatrix,
Intra=Intra,
run_estimation=run_estimation,
alphaFunct1=alphaFunct1,
alphaFunct2=alphaFunct2,
alphaFunct3=alphaFunct3,
alphaFunct4=alphaFunct4
)
##---- 3.2. Run  final fit ----
# Now run a fianl fit of the model to assess parameter
print("Natural Fit beginning")
#install.packages("codetools")
library("codetools")
options(mc.cores = parallel::detectCores())
# defiining initial value of lambda to help with computation failure
# divide by the maximum expected for lambda = U
list.init <- function(...)list(lambdas = array(abs(as.numeric(rnorm(1,
mean=log(fecundity.summary$mean.seed[which(fecundity.summary$focal==Code.focal)])/U,
sd = abs(log(fecundity.summary$st.dev.seed[which(fecundity.summary$focal==Code.focal)])))/
U)),
dim = 1))
if( run.stan == 1){
FinalFit <- stan(file = "code/DensityFunct_Final.stan",
data = DataVec,
init=  list.init,
warmup= 500,
iter = 1000,
init_r = 2,
chains = 3,
control=list(max_treedepth=15),
seed= 165)
save(file= paste0("results/stan/FinalFit_",Code.focal,"_",alpha.function,".rds"),
FinalFit)
}
#load(paste0("results/stan/FinalFit_",Code.focal,"_",alpha.function,".rds"))
load(paste0("results/stan/FinalFit_",Code.focal,"_",alpha.function,".rds"))
FinalPosteriors <- rstan::extract(FinalFit)
print("Final Fit done")
#---- 3.3. Final fit posterior check and behavior checks----
if( run.diagnostic == 1){
##### Diagnostic plots and post prediction
pdf(paste0("figures/stan/FinalFit_",Code.focal,"_",alpha.function,".pdf"))
# Internal checks of the behaviour of the Bayes Modelsummary(PrelimFit)
source("code/stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/stan/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
#log_lik_2 <- loo::extract_log_lik(FinalFit,
#                                  parameter_name = "F_sim",
#                                  merge_chains = F)
#r_eff <- loo::relative_eff(exp(log_lik_2), cores = 2)
# loo_1 <- loo::loo(log_lik_2 , r_eff = r_eff, cores = 2)
# print(loo_1)
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
# plot the corresponding graphs
trace <- stan_trace(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'),
inc_warmup = TRUE)
print(trace)
dens <- stan_dens(FinalFit,
pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
print(dens)
splot <- stan_plot(FinalFit,
pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
print(splot)
sampler_params <- get_sampler_params(FinalFit, inc_warmup = TRUE)
summary(do.call(rbind, sampler_params), digits = 2)
pairs(FinalFit, pars = c("lambdas",'alpha_initial',
'alpha_slope','c'))
# Next check the correlation among key model parameters and identify any
#pairs(FinalFit, pars = c("lambdas",'alpha_initial','alpha_slope','c'))
dev.off()
}
#---- 3.3. Extract coefficients ----
assign(paste0("Parameters_",Code.focal,"_",alpha.function),
list(DataVec = DataVec,
alpha_value= FinalPosteriors$alpha_value,
lambda =  FinalPosteriors$lambda_ei,
alpha_slope= FinalPosteriors$alpha_slope,
alpha_init =FinalPosteriors$alpha_init,
alpha_c = FinalPosteriors$c
))
save(list =paste0("Parameters_",Code.focal,"_",alpha.function),
file = paste0("results/stan/Parameters_",Code.focal,"_",alpha.function,".RData"))
#---- 3.3. Extraction fecundity---
assign(paste0("Fsim_",Code.focal,"_",alpha.function),
list(DataVec = DataVec,
F_sim=FinalPosteriors$F_sim
))
save(list =paste0("Fsim_",Code.focal,"_",alpha.function),
file = paste0("results/stan/Fsim_",Code.focal,"_",alpha.function,".RData"))
}
}
print(paste(Code.focal,", function",function.int))
Code.focal = "HYGA"
print(paste(Code.focal,", function",function.int))
alpha.function <- paste0("function_",function.int)
load(paste0("results/stan/FinalFit_",Code.focal,"_",alpha.function,".rds"))
df_alpha <- data.frame()
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
alpha.function <- paste0("function_",which(function.vec==1))
load(paste0("results/stan/Parameters_",Code.focal,"_",alpha.function,".RData"))
parameters <- get(paste0("Parameters_",Code.focal,"_",alpha.function))
str(parameters[["DataVec"]])
N <- parameters[["DataVec"]]$N
Nmax <- parameters[["DataVec"]]$Nmax
neighbours.vec <- c("forb","grass",focal.levels)
df_alpha_init <- data.frame(observation = c(1:N),
focal = Code.focal,
function.int = function.int)
df_alpha_init <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_init_n <- data.frame(focal = Code.focal,
Nmax=Nmax[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_init"]][,n])),
neigh = neighbours.vec[n],
alpha_init= parameters[["alpha_init"]][,n])
df_alpha_init <- bind_rows(df_alpha_init,df_alpha_init_n)
}
df_alpha_init_n
str(parameters[["alpha_init"]][,n]))
str(parameters[["alpha_init"]][,n])
neighbours.vec[n]
str(df_alpha_slope)
function.int
if (function.int > 1){
df_alpha_slope <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_slope_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_slope"]][,n])),
alpha_slope = parameters[["alpha_slope"]][,n])
df_alpha_slope <- bind_rows(df_alpha_slope,df_alpha_slope_n)
}
if(function.int > 2){
df_alpha_c <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_c_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_c"]][,n])),
alpha_c = parameters[["alpha_c"]][,n])
df_alpha_c <- bind_rows(df_alpha_c,df_alpha_c_n)
}
df_alpha <- full_join(df_alpha_c,full_join(df_alpha_init,df_alpha_slope))
}else{
df_alpha <- full_join(df_alpha_init,df_alpha_slope)
}
}else{
df_alpha <- df_alpha_init
}
str(df_alpha_c )
neighbours.vec <- c("forb","grass",focal.levels)
df_alpha_all <- data.frame(focal=NA)
for(Code.focal in focal.levels){
for (function.int in c(1:4)){
if (Code.focal == "TROR") next
df_alpha <- data.frame()
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
alpha.function <- paste0("function_",which(function.vec==1))
load(paste0("results/stan/Parameters_",Code.focal,"_",alpha.function,".RData"))
parameters <- get(paste0("Parameters_",Code.focal,"_",alpha.function))
N <- parameters[["DataVec"]]$N
Nmax <- parameters[["DataVec"]]$Nmax
neighbours.vec <- c("forb","grass",focal.levels)
df_alpha_init <- data.frame(observation = c(1:N),
focal = Code.focal,
function.int = function.int)
df_alpha_init <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_init_n <- data.frame(focal = Code.focal,
Nmax=Nmax[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_init"]][,n])),
neigh = neighbours.vec[n],
alpha_init= parameters[["alpha_init"]][,n])
df_alpha_init <- bind_rows(df_alpha_init,df_alpha_init_n)
}
if (function.int > 1){
df_alpha_slope <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_slope_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_slope"]][,n])),
alpha_slope = parameters[["alpha_slope"]][,n])
df_alpha_slope <- bind_rows(df_alpha_slope,df_alpha_slope_n)
}
if(function.int > 2){
df_alpha_c <- NULL
for(n in 1:length(neighbours.vec)){
df_alpha_c_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
number = c(1:length(parameters[["alpha_c"]][,n])),
alpha_c = parameters[["alpha_c"]][,n])
df_alpha_c <- bind_rows(df_alpha_c,df_alpha_c_n)
}
df_alpha <- full_join(df_alpha_c,full_join(df_alpha_init,df_alpha_slope))
}else{
df_alpha <- full_join(df_alpha_init,df_alpha_slope)
}
}else{
df_alpha <- df_alpha_init
}
df_alpha_all <- full_join(df_alpha_all,df_alpha)
}
}
df_alpha_all <- df_alpha_all[-1,] # nrow = 120 == 4(fct) * 5(species) * 6(neighbours)
str(df_alpha_all)
view(df_alpha_all)
df_funct_alpha <- NULL
for (n in 1:nrow(df_alpha_all)){
print(n)
df_funct_alpha_n <- df_alpha_all[n,]
df_funct_alpha_n <- data.frame(density=c(0:10),df_funct_alpha_n)
if(df_funct_alpha_n$function.int[1]==1){
df_funct_alpha_n$alpha_value <- df_funct_alpha_n$alpha_init
}
if(df_funct_alpha_n$function.int[1]==2){
df_funct_alpha_n$alpha_value <- alpha_function2(df_funct_alpha_n$alpha_init,
df_funct_alpha_n$alpha_slope,
df_funct_alpha_n$density,
df_funct_alpha_n$Nmax)
}
if(df_funct_alpha_n$function.int[1]==3){
df_funct_alpha_n$alpha_value <- alpha_function3(df_funct_alpha_n$alpha_init,
df_funct_alpha_n$alpha_slope,
df_funct_alpha_n$alpha_c,
df_funct_alpha_n$density,
df_funct_alpha_n$Nmax)
}
if(df_funct_alpha_n$function.int[1]==4){
df_funct_alpha_n$alpha_value <- alpha_function4(df_funct_alpha_n$alpha_init,
df_funct_alpha_n$alpha_slope,
df_funct_alpha_n$alpha_c,
df_funct_alpha_n$density,
df_funct_alpha_n$Nmax)
}
df_funct_alpha <- bind_rows(df_funct_alpha,df_funct_alpha_n )
}
write.csv(df_funct_alpha,
"results/df_funct_alpha.csv.gz")
cbp2 <- c("#000000", "#E69F00", "#56B4E9","#F0E442","#009E73",
"#CC79A7", "#0072B2", "#D55E00")
cb2_focal <- c("#E69F00", "#56B4E9","#009E73","#CC79A7")
plot.list.alpha <- list()
# percentage of positive interaction with function 4
100*nrow(df_funct_alpha[which(df_funct_alpha$function.int == 4 &
df_funct_alpha$alpha_value > 0),])/
nrow(df_funct_alpha[which(df_funct_alpha$function.int == 4),])
for( n in 1:4){
df <- df_funct_alpha[which(df_funct_alpha$focal == focal.levels[n]),]
plot.list.alpha[[n]] <- ggplot(df,aes(x=density, y= alpha_value,
color=neigh,fill=neigh)) +
stat_smooth(method = 'gam',se = TRUE,level =0.95) +
facet_wrap(. ~ function.int, strip.position = "top",
nrow=1, ncol=4, scales = "fixed") +
scale_color_manual("neighbours identity",values=cbp2[2:7]) +
scale_fill_manual("neighbours identity",values=cbp2[2:7]) +
theme_bw() +
labs(title = element_text(focal.levels[n],
color=cb2_focal[n]),
y= "Effect of neighbours on focal",
x="density of neighbours") +
rremove("ylab") + rremove("xlab") +
geom_hline(yintercept=0, color="black", linetype="dashed") +
theme(plot.title = element_text(color=cb2_focal[n],
vjust = -5),
strip.background = element_blank(),
strip.placement = "outside",
strip.text =element_text(color="black"),
legend.key= element_rect(fill = "white"),
plot.margin = unit(c(-1,0.2,0,0.2), 'lines'))
}
plot.alpha_all <- ggarrange(plotlist = plot.list.alpha,
labels = NULL,
align = "hv",
font.label = list(size = 10, color = "black",
face = "bold", family = NULL, position = "top"),
nrow=4, common.legend=T, legend="right")
for( n in 1:4){
df <- df_funct_alpha[which(df_funct_alpha$focal == focal.levels[n]),]
plot.list.alpha[[n]] <- ggplot(df,aes(x=density, y= alpha_value,
color=neigh,fill=neigh)) +
stat_smooth(method = 'gam',se = TRUE,level =0.95) +
facet_wrap(. ~ function.int, strip.position = "top",
nrow=1, ncol=4, scales = "fixed") +
scale_color_manual("neighbours identity",values=cbp2[2:9]) +
scale_fill_manual("neighbours identity",values=cbp2[2:9]) +
theme_bw() +
labs(title = element_text(focal.levels[n],
color=cb2_focal[n]),
y= "Effect of neighbours on focal",
x="density of neighbours") +
rremove("ylab") + rremove("xlab") +
geom_hline(yintercept=0, color="black", linetype="dashed") +
theme(plot.title = element_text(color=cb2_focal[n],
vjust = -5),
strip.background = element_blank(),
strip.placement = "outside",
strip.text =element_text(color="black"),
legend.key= element_rect(fill = "white"),
plot.margin = unit(c(-1,0.2,0,0.2), 'lines'))
}
plot.alpha_all <- ggarrange(plotlist = plot.list.alpha,
labels = NULL,
align = "hv",
font.label = list(size = 10, color = "black",
face = "bold", family = NULL, position = "top"),
nrow=4, common.legend=T, legend="right")
library(grid)
plot.alpha_all <- annotate_figure(plot.alpha_all, left = textGrob("Effect of neighbours on focal", rot = 90, vjust = 1, gp = gpar(cex = 1.3)),
bottom = textGrob("density of neighbours", gp = gpar(cex = 1.3)))
ggsave(plot.alpha_all,
file = "figures/NatData_plot_alpha_all.pdf")
df_param_all <- data.frame(focal=NA)
for(Code.focal in focal.levels){
for (function.int in c(1:4)){
if (Code.focal == "TROR") next
df_param <- data.frame()
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
alpha.function <- paste0("function_",which(function.vec==1))
load(paste0("results/stan/Parameters_",Code.focal,"_",alpha.function,".RData"))
parameters <- get(paste0("Parameters_",Code.focal,"_",alpha.function))
N <- parameters[["DataVec"]]$N
Nmax <- parameters[["DataVec"]]$Nmax
neighbours.vec <- c("forb","grass",focal.levels)
df_param_init <- data.frame(observation = c(1:N),
focal = Code.focal,
function.int = function.int)
df_param_init <- NULL
for(n in 1:length(neighbours.vec)){
df_param_init_n <- data.frame(focal = Code.focal,
Nmax=Nmax[n],
function.int = function.int,
neigh = neighbours.vec[n],
lambda= mean(parameters[["lambda"]]),
alpha_init= mean(parameters[["alpha_init"]][,n]))
df_param_init <- bind_rows(df_param_init,df_param_init_n)
}
if (function.int > 1){
df_param_slope <- NULL
for(n in 1:length(neighbours.vec)){
df_param_slope_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
alpha_slope = mean(parameters[["alpha_slope"]][,n]))
df_param_slope <- bind_rows(df_param_slope,df_param_slope_n)
}
if(function.int > 2){
df_param_c <- NULL
for(n in 1:length(neighbours.vec)){
df_param_c_n <- data.frame(focal = Code.focal,
neigh = neighbours.vec[n],
function.int = function.int,
alpha_c = mean(parameters[["alpha_c"]][,n]))
df_param_c <- bind_rows(df_param_c,df_param_c_n)
}
df_param <- full_join(df_param_c,full_join(df_param_init,df_param_slope))
}else{
df_param <- full_join(df_param_init,df_param_slope)
}
}else{
df_param <- df_param_init
}
df_param_all <- full_join(df_param_all,df_param)
}
}
df_param_all <- df_param_all[-1,] # nrow = 120 == 4(fct) * 5(species) * 6(neighbours)
str(df_param_all)
df_projection <- NULL
levels(as.factor(df_param_all$lambda))
for (function.int in c(1:4)){
param.df <- df_param_all[which(df_param_all$function.int==function.int),]
param.df$g = 1
param.df$s = 1
state = c(1)
df_projection_n <- Ricker_solution_NatData(gens = 250,
state,pars = param.df)
df_projection_n$function.int <- function.int
df_projection <-  bind_rows(df_projection, df_projection_n)
}
plot_projection <- df_projection %>%
gather(all_of(c(focal.levels,"neighbours")), key="species", value="abundance") %>%
ggplot(aes(y=abundance, x= time, group=species, color=species)) +
geom_smooth() + scale_y_log10() +
facet_grid(.~as.factor(function.int),
scales="free") +
theme_bw()
plot_projection <- df_projection %>%
gather(all_of(   neighbours.vec ), key="species", value="abundance") %>%
ggplot(aes(y=abundance, x= time, group=species, color=species)) +
geom_smooth() + scale_y_log10() +
facet_grid(.~as.factor(function.int),
scales="free") +
theme_bw()
plot_projection
ggsave(plot_projection,
file = "figures/NatData_plot_projection.pdf")
