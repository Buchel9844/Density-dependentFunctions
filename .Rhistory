color=density.function,
fill=density.function)) +
geom_point(aes(
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none",color="none")+
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ")
AlphadistributionGraph
library(shiny); runApp('shiny/functions.R')
aggregate(proba~ alpha.function,df.proba)
aggregate(proba~ alpha.function,df.proba,function(x) sum(x)/100)
aggregate(proba~ alpha.function,df.proba,function(x) sum(x))
df.proba.recap <- aggregate(proba~ alpha.function,
df.proba,
function(x) sum(x))
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= abundance.neighbours,
y=alpha_mean)) +
geom_smooth(alpha=0.5,se=F, aes(
color=density.function,
fill=density.function)) +
geom_point(aes(
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none",color="below")+
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ")
AlphadistributionGraph
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= abundance.neighbours,
y=alpha_mean)) +
geom_smooth(alpha=0.5,se=F, aes(
color=density.function,
fill=density.function)) +
geom_point(aes(
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none",color="bottom")+
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ")
AlphadistributionGraph
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= abundance.neighbours,
y=alpha_mean)) +
geom_smooth(alpha=0.5,se=F, aes(
color=density.function,
fill=density.function)) +
geom_point(aes(
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none",color="right")+
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ")
AlphadistributionGraph
AlphadistributionGraph <- ggplot(Alphadistribution.neighbours, aes(x= abundance.neighbours,
y=alpha_mean)) +
geom_smooth(alpha=0.5,se=F, aes(
color=density.function,
fill=density.function)) +
geom_point(aes(
color=density.function,
fill=density.function)) +
#ylim(-0.1,0.1)+
geom_hline(yintercept=0,color="dark grey") +
xlim(0,max(Alphadistribution.neighbours$abundance.neighbours)) +
geom_errorbar(aes(ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
color=density.function), width=.2,
position=position_dodge(0.05)) +
facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() +
guides(fill="none")+
scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
labs(title="Direct interactions distributions of the 4 density-dependent functions",
y="Resulting effect", x=" Neighbour density ")
AlphadistributionGraph
df.proba.recap
ggsave("figures/simulated.seed.density.pdf",
plot = ggplot(Generate.simulated.data,
aes(x=fecundity,
group = sim)) +
geom_density(alpha=0.6) +
#scale_color_manual(values=c("blue","red")) +
facet_wrap(focal~.) +
xlab("Viable seed, fecundity per individuals") +
theme_bw()
)
ggplot(Generate.simulated.data,
aes(x=fecundity,
group = sim)) +
geom_density(alpha=0.6) +
#scale_color_manual(values=c("blue","red")) +
facet_wrap(focal~.) +
xlab("Viable seed, fecundity per individuals") +
theme_bw()
ggplot(Generate.experimental.outcomes) +
geom_point( aes(x=biomass.i,y=biomass.j,
color = sim),alpha=0.3) +
#geom_smooth( aes(x=biomass.i,y=biomass.j),color="grey",alpha=0.6) +
#xlim(0.875,1)+
#ylim(0,0.6) +
theme_bw()+
labs(title="Biomass of species j in function of biomass of species i")
# the community dynamics over 10 seasons is as followed:
source("code\GenerateConitunousData-Stouffer.R")
getwd()
# the community dynamics over 10 seasons is as followed:
source("code\GenerateContinuousData-Stouffer.R")
# libraries required to run the code
library(odeintr)
# to use/run the 2sp model
#source('lib/model.2sp.R')
#################################################
# define initial conditions and model parameters
#################################################
# initial conditions for viable seeds in seed bank
N0 <- c(770, 25000)
# number of years to simulate
nyears <- 10
# define all parameter values for seed germination phase
# paired values are always ordered (i, j)
params.seed <- list(
T     = 0.50,
gamma = c(0.10, 0.01),# germination rate of seeds
mu    = c(0.10, 0.20), # mortality rate of seeds
nu    = c(0.00, 0.00), # mortality rate of ind
r     = c(0.00, 0.00), # intrinsic growth rate
K     = c(100.0, 250.0), # carrying capacity
beta  = c(0.02, 0.02), # biomass of germinant
alpha_ij = -0.1,
alpha_ji = 0.50
)
# define all parameter values for plant growth phase
# paired values are always ordered (i, j)
params.plant <- list(
T     = 0.50,
gamma = c(0.00, 0.001), # germination rate of seeds
mu    = c(0.10, 0.20), # mortality rate of seeds
nu    = c(0.20, 0.05), # mortality rate of ind
r     = c(10.00, 10.00), # intrinsic growth rate
K     = c(100.0, 250.0), # carrying capacity
beta  = c(0.2, 0.2), # biomass of germinant
alpha_ij = 0.05, #competitive effect of j on i
alpha_ji = 0.50, #competitive effect of i on j
phi   = c(10,25) # conversion rate from biomass to seed
)
################################################
# simulate continuous-time population dynamics
# using above initial conditions and parameters
################################################
# initial conditions including viable seeds, plants, and biomass
population.dynamics <- matrix(
c(
0,
N0[1], 0, 0,
N0[2], 0, 0
),
byrow=TRUE,
nrow=1
)
colnames(population.dynamics) <- c(
"Time",
"Seeds i",
"Plants i",
"Biomass i",
"Seeds j",
"Plants j",
"Biomass j"
)
# run simulation for the specified number of years
for(year in 0:(nyears-1)){
# set the parameters for phase 1
fecundity_dynamics_set_params(
gamma_i = params.seed$gamma[1],
mu_i = params.seed$mu[1],
nu_i = params.seed$nu[1],
r_i = params.seed$r[1],
K_i = params.seed$K[1],
beta_i = params.seed$beta[1],
gamma_j = params.seed$gamma[2],
mu_j = params.seed$mu[2],
nu_j = params.seed$nu[2],
r_j = params.seed$r[2],
K_j = params.seed$K[2],
beta_j = params.seed$beta[2],
alpha_ij = params.seed$alpha_ij,
alpha_ji = params.seed$alpha_ji
)
# simulate phase 1
NPBseed <- fecundity_dynamics(
init=population.dynamics[nrow(population.dynamics),2:7],
duration=params.seed$T[1],
step_size=params.seed$T[1]/1000.,
start=year
)
# add phase 1 dynamics to pop dyn container
population.dynamics <- rbind(population.dynamics, as.matrix(NPBseed))
# set the parameters for phase 2
fecundity_dynamics_set_params(
gamma_i = params.plant$gamma[1],
mu_i = params.plant$mu[1],
nu_i = params.plant$nu[1],
r_i = params.plant$r[1],
K_i = params.plant$K[1],
beta_i = params.plant$beta[1],
gamma_j = params.plant$gamma[2],
mu_j = params.plant$mu[2],
nu_j = params.plant$nu[2],
r_j = params.plant$r[2],
K_j = params.plant$K[2],
beta_j = params.plant$beta[2],
alpha_ij = params.plant$alpha_ij,
alpha_ji = params.plant$alpha_ji
)
# simulate phase 2
NPBplant <- fecundity_dynamics(
init=population.dynamics[nrow(population.dynamics),2:7],
duration=params.plant$T[1],
step_size=params.plant$T[1]/1000.,
start=population.dynamics[nrow(population.dynamics),1]
)
# add phase 2 dynamics to pop dyn container
population.dynamics <- rbind(population.dynamics, as.matrix(NPBplant))
# convert biomass to seeds, kill all plants, remove their biomass
end.state <- population.dynamics[nrow(population.dynamics),]
end.state["Seeds i"] <- end.state["Seeds i"] + params.plant$phi[1] * end.state["Biomass i"]
end.state["Seeds j"] <- end.state["Seeds j"] + params.plant$phi[2] * end.state["Biomass j"]
end.state["Plants i"] <- end.state["Plants j"] <- 0
end.state["Biomass i"] <- end.state["Biomass j"] <- 0
# add this last step to the population dynamics
population.dynamics <- rbind(population.dynamics, end.state)
}
exp(-3)
exp(-3*5)
exp(2)
exp(0.5)
exp(-0.5)
10!
10*9*8*7*6*5*4*3*2
10+9+8+7+6+5+4+3+2
45*3
10*6
45*6
runApp('shiny/functions.R')
#install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
library(rstan)
#install.packages("HDInterval")
library("HDInterval")
#install.packages("tidyverse")
library("tidyverse")
#install.packages("dplyr")
library(dplyr)
library(ggpubr)
library(ggplot2)
Generate.experimental.outcomes <- read.csv("results/Generate.experimental.outcomes.csv")
Generate.simulated.data <- read.csv("results/Generate.simulated.data.csv")
load(paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds"))
paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds")
FinalPosteriors <- rstan::extract(FinalFit)
stan_trace(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
stan_dens(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
stan_plot(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
F_sim = extract(FinalFit, c("  F_sim"))[[1]]
F_sim = extract(FinalFit, c("F_sim"))[[1]]
F_sim = rstan::extract(FinalFit, c("F_sim"))[[1]]
plot(Fecundity, pch=16)
dataEllipse(F_sim, levels = c(0.5, 0.95),
fill=T, plot.points = FALSE)
plot(Fecundity, pch=16)
rstan::dataEllipse(F_sim, levels = c(0.5, 0.95),
fill=T, plot.points = FALSE)
library(car)
plot(Fecundity, pch=16)
dataEllipse(F_sim, levels = c(0.5, 0.95),
fill=T, plot.points = FALSE)
print(FinalFit)
paste0("results/FinalFit_",Code.focal,"_",alpha.function,".rds")
F_sim = rstan::extract(FinalFit, c("F_sim"))
plot(Fecundity, pch=16)
dataEllipse(F_sim, levels = c(0.5, 0.95),
fill=T, plot.points = FALSE)
plot(Fecundity, pch=16)
# functions from Rstan pacakges
stan_trace(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'),
inc_warmup = TRUE)
sampler_params <- get_sampler_params(FinalFit, inc_warmup = TRUE)
summary(do.call(rbind, sampler_params), digits = 2)
pairs(FinalFit, pars = c("lambdas",'alpha_initial','alpha_slope','c'))
install.packages("loo")
install.packages("loo")
install.packages("loo")
install.packages("loo")
library(loo)
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik_1 <- extract_log_lik(FinalFit, merge_chains = FALSE)
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik_1 <- extract_F_sim(FinalFit, merge_chains = FALSE)
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik_1 <- rstan::extract(FinalFit[["F_sim"]], merge_chains = FALSE)
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
FinalPosteriors <- rstan::extract(FinalFit)
log_lik_1 <- rstan::extract(FinalPosteriors$F_sim, merge_chains = FALSE)
r_eff <- relative_eff(FinalPosteriors$F_sim, cores = 2)
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to
# use with relative_eff()
log_lik_2 <- loo::extract_log_lik(FinalFit, merge_chains = FALSE)
log_lik_2 <- loo::extract_F_sim(FinalFit, merge_chains = FALSE)
print(paste(Code.focal,", function",function.int))
function.int = 3
print(paste(Code.focal,", function",function.int))
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# subset for one Code.focal species
SpDataFocal <- simdata[which(simdata$focal == Code.focal),]
#SpDataFocal <- simdata
#SpDataFocal <- SpDataFocal[which(SpDataFocal$focal == Code.focal),]
SpDataFocal <- SpDataFocal[complete.cases(SpDataFocal$fecundity),]
#SpDataFocal$seeds[is.na(SpDataFocal$seeds)] <- 0
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$fecundity)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("time","focal","seeds.i",
"seeds.j","fecundity",
"seeds","biomass")]
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(AllSpNames))
library(rstan)
#install.packages("loo")
library(loo) # Efficient approximate leave-one-out cross-validation
#install.packages("HDInterval")
library("HDInterval")
#install.packages("tidyverse")
library("tidyverse")
#install.packages("dplyr")
library(dplyr)
library(ggpubr)
library(ggplot2)
print(paste(Code.focal,", function",function.int))
function.vec <- c(0,0,0,0)
function.vec[function.int] <- 1
# subset for one Code.focal species
SpDataFocal <- simdata[which(simdata$focal == Code.focal),]
#SpDataFocal <- simdata
#SpDataFocal <- SpDataFocal[which(SpDataFocal$focal == Code.focal),]
SpDataFocal <- SpDataFocal[complete.cases(SpDataFocal$fecundity),]
#SpDataFocal$seeds[is.na(SpDataFocal$seeds)] <- 0
# Next continue to extract the data needed to run the model.
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$fecundity)
#---- 2. ABUDANCE MATRIX----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 2.1. Interaction (direct) matrix of plant with COMP ----
# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("time","focal","seeds.i",
"seeds.j","fecundity",
"seeds","biomass")]
AllSpAbunds <- SpDataFocal %>%
dplyr::select(all_of(AllSpNames))
SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0
S <- sum(SpToKeep)
SpMatrix <- matrix(NA, nrow = N, ncol = S)
i <- 1
for(s in 1:ncol(AllSpAbunds)){
if(SpToKeep[s] == 1){
SpMatrix[,i] <- AllSpAbunds[,s]
i <- i + 1
}else{next}
}
#SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
#if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}
SpNames <- AllSpNames[SpToKeep]
#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == paste0("plants.",Code.focal), 1, 0)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#---- 3. BAYES FIT----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##---- 3.1. Set up summary interactions df and parameters ----
run_estimation <- 1
alphaFunct1 <- function.vec[1]
alphaFunct2 <- function.vec[2]
alphaFunct3 <- function.vec[3]
alphaFunct4 <- function.vec[4]
alpha.function <- paste0("function_",which(function.vec==1))
DataVec <- c("N", "S",
"Fecundity", "SpMatrix",
"Intra","run_estimation","alphaFunct1",
"alphaFunct2","alphaFunct3","alphaFunct4")
##---- 3.2. Run  final fit ----
# Now run a fianl fit of the model to assess parameter
print("Final Fit beginning")
#install.packages("codetools")
library("codetools")
options(mc.cores = parallel::detectCores())
FinalFit <- stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
FinalPosteriors <- rstan::extract(FinalFit)
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
# N.B. amount by which autocorrelation within the chains increases uncertainty in estimates can be measured
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
stan_trace(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'),
inc_warmup = TRUE)
stan_dens(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
stan_plot(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
Fecundity
ggplot(SpDataFocal) +
geom_density(aes(x=fecundity)) + xlim(0,500)
SpMatrix
options(mc.cores = parallel::detectCores())
FinalFit <- stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
FinalPosteriors <- rstan::extract(FinalFit)
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
alpha.function
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
stan_trace(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'),
inc_warmup = TRUE)
stan_dens(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
stan_plot(FinalFit, pars=c('lambdas','c','alpha_initial','alpha_slope','c'))
FinalFit <- stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
FinalFit <- rstan::stan(file = "code/DensityFunct_BH_Final.stan",
data = DataVec,
init="random",
warmup= 500,
iter = 1000,
chains = 3)
FinalPosteriors <- rstan::extract(FinalFit)
# check the distribution of Rhats and effective sample sizes
##### Posterior check
stan_post_pred_check(FinalPosteriors,"F_hat",Fecundity,
paste0("results/PostFec_",Code.focal,"_",alpha.function,".csv.gz"))
hist(summary(FinalFit)$summary[,"Rhat"],
main = paste("Finat Fit: Histogram of Rhat for",
Code.focal," and ",alpha.function))
hist(summary(FinalFit)$summary[,"n_eff"],
main = paste("Finat Fit: Histogram of Neff for",
Code.focal," and ",alpha.function))
