---
title: "Analysis summary"
output: 
  pdf_document: 
    toc: true
    toc_depth: 3
    extra_dependencies: ["float"]
date: "2023-06-28"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE)
library(rstan)
library(loo) # Efficient approximate leave-one-out cross-validation
library("HDInterval")
library(tidyverse)
library(dplyr)
library(ggpubr)
library(ggplot2)
library(odeintr)
library(brms)
library(bbmle)
#tinytex::reinstall_tinytex()
library(tinytex)
library(purrr)
```

# Species interactions as density-denpendent function
## Motivation
Species interactions are traditionally set to a constant per capita effect of the addition of one neighbour on the fecundity of the focal species. To set them as a constant remove the potential of the interactive effect to change from facilitation (positive) to competition (negative) when the density of the neighbour increases.
If we set species interactions to density-dependent functions for a two-species community, we hypothesized that the projected community trajectory would have a better match to observation/reality. 

## Theorethical functions

### Equations of the theorethical functions
Four functions dependent on neighbours density were built: 
+ (1) constant interaction
$$\alpha_{ij} = \alpha_{0,i,j}$$
+ (2) linear interaction
$$\alpha_{ij} = \alpha_{0,i,j} + \alpha_{1,i,j}*g_j*(N_j - N_{j,0})$$
+ (3) negative exponential interaction
$$\alpha_{ij} = \alpha_{0,i,j} + \alpha_{1,i,j}*(1-e^{-c_i*g_j*(N_j - N_{j,0}})$$
+ (4) sigmoidal interaction
$$\alpha_{ij} = \alpha_{0,i,j} + \frac{c_i*(1-e^{-\alpha_{1,i,j}*g_j*(N_j - N_{j,0})})}{1+e^{-\alpha_{1,i,j}*g_j*(N_j - N_{j,0})}}$$
$N_0$ is the density of species $j$ when the focal $i$ has its highest fecundity observed ($[0,R^+]$); $g_j$ is the germination rate of species $j$; $N_j$ is the viable seed density of species $j$ ($[0,R^+]$); $g_j*N_j$ is the observed density of germinated species $j$; $g_j*N_{0,j}$ is the density species $j$ when species $i$ reached its maximum observed fecundity; $\alpha_{0,i,j}$ is the minimal effect of $j$ on $i$ when $N_j-N_0$ is equal to 0 ($[-1,-1]$); $\alpha_{1,i,j}$ is the effect of the addition of one unit of $j$ ($[-1,-1]$); $c_{i}$ is a stretching coefficient ($[0,1]$).The reciprocal function can be established for $\alpha_ii$. Noted that we use the difference of observed density $g_j*N_j$ and optimal density $g_j*N_{0,j}$ to infer that species $i$ do not have to reach maximum fitness when growing alone.  To avoid the coefficeint to become extremely large, the follwoing condition was set for the 3 last functions: 
if $g_j*(N_j - N_{0,j}) > 10$, $\alpha_{i,j}$ is set has the value when $g_j*(N_j - N_{0,j}) = 10$

The interaction effects are implemented into a density dependent fecundity model knows at the Ricker model of the following form: 
$$F_i = \lambda_i e^{\alpha_ii N_i + \alpha_ij N_j}$$
with $\lambda_i$ the intrinsic fecundity of focal $i$. 
Please see the annexed Shiny-app to play with the 4 functions and visualized their matching fecundity distribution. 


### Test functions on an artifical community
To verify that the function can correctly retrieve interaction effects, we simulated a community with the Ricker model (above), with specific interaction effects. The two species have the following fecundity distribution: 
```{r Ricker distributions, echo=FALSE, , include=FALSE}
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/GenerateSimData_Ricker.R",local = knitr::knit_global()) 
set.seed(16)
simul_data_ricker <- simul_data(S = 2,   # number of focal groups/species
                                K = 2,   # number of neighbour focals 
                                pI = 0.1) # Generate Simulated data in "simulated.data" df and
simdata <- simul_data_ricker$simdata
cols.num <- c("seeds","i","j")
simdata[cols.num] <- sapply(simdata[cols.num],as.numeric)
ggplot(simdata, aes(x=seeds, color=as.factor(focal))) + 
         geom_density(alpha=0.5) + 
         scale_x_continuous(name = "Viable seed, fecundity per individuals (log transformed)", limits=c(0,200)) + 
         theme_bw() 
```
The community was fit in Bayesian model with the following prior: $\lambda_i \sim  N(0,1^+)$, $\alpha_{0,i,j} \sim N(-1,1)$, $\alpha_{1,i,j} \sim N(-1,1)$, and $c_i \sim N(-1,1)$. Parameters were estimated following a negative binomial (Rstan neg_binomial_2). Here are the estimated interaction effect for each function, compared to the initial value set, in blue.


```{r Ricker alpha, echo=FALSE}
load("results/Alphadistribution.neighbours.Ricker.csv.gz")

sim_alpha_specific <- as.data.frame(simul_data_ricker$sim_alpha_specific) %>%
  rownames_to_column(var = "focal") %>%
  gather(alphai,alphaj,key="neighbours" ,value="alpha_sim") %>%
  mutate(focal = case_when(focal == "focali" ~ "species i",
                           focal == "focalj" ~ "species j"),
         neighbours = case_when(neighbours == "alphai" ~ "species i",
                                neighbours == "alphaj" ~ "species j"))

ggplot() + 
  geom_smooth(data=Alphadistribution.neighbours.Ricker, aes(x= abundance.neighbours,
                                                       y=alpha_mean,
    color=density.function,
    fill=density.function),
    alpha=0.5,se=F) +
  geom_point(data=Alphadistribution.neighbours.Ricker,aes(
    x= abundance.neighbours,
    y=alpha_mean,
    color=density.function,
    fill=density.function)) +
  #ylim(-0.1,0.1)+
  geom_hline(yintercept=0,color="dark grey") +
  geom_hline( data=sim_alpha_specific ,aes(yintercept=alpha_sim),color="blue") + 
  geom_errorbar(data=Alphadistribution.neighbours.Ricker, 
                aes(x= abundance.neighbours,
                    y=alpha_mean,
                    ymin=alpha_mean-alpha_sd^2, ymax=alpha_mean+alpha_sd^2,
                    color=density.function), width=.2,
                position=position_dodge(0.05)) +
  facet_grid( focal ~ neighbours,scale="free", switch="both") + theme_bw() + 
  guides(fill="none") +
  scale_color_manual("Density-dependent functions",values=c("black","#CC79A7","#E69F00","#009E73")) +
  labs(title="Direct interactions distributions of the 4 density-dependent functions from RICKER simulation data", 
       y="Resulting effect", x=" Neighbour density ")

```


# Example on 3 Competitive communities

## Three competitive scenarios

For the three community, one species $j$ invade a species $i$, below are the common and specific parameters for each scenario. Parameters are always order by c(i,j). The parameters are fit in Stouffer,2023 - MethEcoEvo model. Scripts have been modified from Stouffer original scripts. The graphs below shows the population dynamics for the first scenario (untitled "low"). 

```{r common par, echo=TRUE}
# initial conditions for viable seeds in seed bank
scenario <- "low" #c("low","medium","high"))
N0 <- c(200,10) # number of seeds in the seed bank
time.exp.max <- 5 # year observations finish
time.exp.min <- 2 # year observations start
nyears <- 30 # number of years to simulate 
params.low <- list( # low mortality rate of j - j is better competitor
  mu    = c(0.10, 0.05), # mortality rate of seeds
  nu    = c(0.10, 0.05), # mortality rate of ind
  alpha_ij = 0.75 , #competitive effect of j on i
  alpha_ji = 0.40 #competitive effect of i on j
)

params.medium <- list( # medium mortality rate of j - equal competitor
  mu    = c(0.10, 0.1), # mortality rate of seeds
  nu    = c(0.10, 0.1), # mortality rate of ind
  alpha_ij = 0.40 , #competitive effect of j on i
  alpha_ji = 0.40 #competitive effect of i on j

)
params.high <- list( # high mortality rate of j - j is the inferior competitor
  mu    = c(0.10, 0.50), # mortality rate of seeds
  nu    = c(0.10, 0.50), # mortality rate of ind
  alpha_ij = 0.05 , #competitive effect of j on i
  alpha_ji = 0.40 #competitive effect of i on j
)
params <- append(get(paste0("params.",scenario)), # for adult growth phase
                 list( # constant parameters
                   T     = 0.50,
                   gamma = c(0.1, 0.1), # germination rate of seeds
                   r     = c(2.00, 2.00), # intrinsic growth rate
                   K     = c(25.0, 25.0), # carrying capacity
                   beta  = c(0.2, 0.2), # biomass of germinant 
                   phi   = c(5,5) # conversion rate from biomass to seed
                 ))

params.plant <- params #for plant growth phase

params.seed <- append(get(paste0("params.",scenario)), # for seed growth phase
                      list( # constant parameters
                        T     = 0.50,
                        gamma = c(0.7, 0.7), # germination rate of seeds
                        r     = c(0.00, 0.00), # intrinsic growth rate
                        K     = c(25.0, 25.0), # carrying capacity
                        beta  = c(0.2, 0.2) # biomass of germinant 
                      ))
random.set <- 1616
set.seed(random.set) #to create reproducible results
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/GenerateSimData-Stouffer.R", local = knitr::knit_global()) # Generate Simulated data in "simulated.data" df and 

source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/GenerateContinuousData-Stouffer.R", local = knitr::knit_global()) 


```

## Bayesian approach

For each scenario, we fitted the same Bayesian approach than above, with the same priors. Minimal conditions of convergence for bayesian models are a Rhat < 1.1 and a Neff > 100. 
```{r bayes cdt, echo=FALSE}
ModelCheck <- NULL
for( scenario in c("low","medium","high")){
  for(Code.focal in c("i","j")){ #,"j"
    for (function.int in c(1:4)){ # c(1:4)
      
      #print(paste(scenario, Code.focal,", function",function.int))
    
      load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
      mc <- data.frame( scenario = scenario, focal =Code.focal, 
                        function.int = function.int,
                        Rhat = max(summary(FinalFit)$summary[,"Rhat"],na.rm =T),
                        Neff = min(summary(FinalFit)$summary[,"n_eff"],na.rm = T))
      ModelCheck <- bind_rows(ModelCheck,mc)
      #remove(FinalFit)
    }
  }
}
  ModelCheck
```

To evaluate which density dependent functions fits best each focal species for each scenario, we look at the loglikelihood with the loo package. 

```{r mage-bayes-models, echo=FALSE}
source("/Users/lisabuche/Documents/Projects/Density-dependentFunctions/code/stan_modelcheck_rem.R", local = knitr::knit_global())
Se_loo_model <- read_csv("results/Se_loo_model.csv")

for( scenario in c("low","medium","high")){
  par(oma=c(0,0,0,0), mar=c(2.25,2.5,2,1))
  layout(mat = matrix(
    1:8,
    byrow=TRUE,
    nrow = 2,
    ncol = 4
  ),
  heights = c(6,6),
  widths = rep(3,8)
  )
  
  for(Code.focal in c("i","j")){ #,"j"
    for (function.int in c(1:4)){ # c(1:4)
      
load(paste0("results/FinalFit_",scenario,"_",Code.focal,"_function_",function.int,".rds"))
simdata <- read.csv(paste0("results/Generate.simulated.data.",scenario,".csv"))
simdata <- simdata[which(simdata$time >= time.exp.min & 
                           simdata$time < time.exp.max &
                           simdata$focal == Code.focal),]

col2 <- c("black","#CC79A7","#E69F00","#009E73")
col1 <- c("blue","red")

if(Code.focal=="i"){int.focal <- 1}else{int.focal <- 2}    
value.se <- round(Se_loo_model$se_diff[which(Se_loo_model$model == function.int &
                                         Se_loo_model$scenario == scenario &
                                         Se_loo_model$focal == Code.focal)],digits=2)

FinalPosteriors <- rstan::extract(FinalFit)
stan_post_pred_check_all(FinalPosteriors,"F_hat",
                     simdata$fecundity[!is.na(simdata$fecundity)],
                     paste0(scenario,"for species ",Code.focal,",function ",function.int),
                     col1[int.focal],
                     col2[function.int ],
                     value.se) 


    }
  }
}
```

The approach estimates interaction effects.\
Low scenario - parameters set species $j$ has the superior competitor:

```{r mage-bayes-alpha-low, out.width = "95%", fig.cap = "caption", echo = FALSE,fig.pos = "H"}
knitr::include_graphics(path = "/Users/lisabuche/Documents/Projects/Density-dependentFunctions/figures/AlphadistributionGraphlow.pdf")
```

Medium scenario - parameters set species $j$ has an equal competitor to species $i$:

```{r mage-bayes-alpha-medium, out.width = "95%", fig.cap = "caption", echo = FALSE,fig.pos = "H"}
knitr::include_graphics(path = "/Users/lisabuche/Documents/Projects/Density-dependentFunctions/figures/AlphadistributionGraphmedium.pdf")
```

High scenario - parameters set species $j$ has the inferior competitor:

```{r mage-bayes-alpha-high, out.width = "95%", fig.cap = "caption", echo = FALSE,fig.pos = "H"}
knitr::include_graphics(path = "/Users/lisabuche/Documents/Projects/Density-dependentFunctions/figures/AlphadistributionGraphhigh.pdf")
```

# Population projection

We can evaluate which density dependent functions has the best projection compared to the observed community projection. The population projections are not great, which I am working on to understand why.  

```{r projection population, echo=FALSE}

df.pop.proj.l <- read.csv("results/PopProjection.csv")
population.dynamics.all <- read.csv("results/population.dynamics.all.csv")

ggplot() + geom_line(data=df.pop.proj.l,aes(x=t, y=N, colour=Population)) +
  geom_point(data=df.pop.proj.l,aes(x=t, y=N, colour=Population)) +
  facet_grid(scenario~function.int, scale="free") + 
  geom_line(data=population.dynamics.all,
            aes(x=Time-time.exp.max, y=N, colour=Population),
            alpha=0.5) +
  theme_bw() +scale_y_log10(limits=c(1e-6,1e6)) +
  scale_color_manual(values=c("black","red")) +
  
  labs(title = "Projection of seed trajectory for species i (native) and j (competitor)",
       x="Generations", y="Density of viable seeds")


```
 



